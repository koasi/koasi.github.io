import{e as Ne,G as m,C as ue,b as L,c as l,M as F,s as g,T as f,$ as t,d as D,A as ge,a as De,f as H,E as Re,t as N}from"./DarkTheme-6565bed1.js";import{F as A,M as xe,a as B,r as Ee,W as z,b as Ue,d as $e,N as pe,e as K,P as V,s as j,B as Ge,i as ne,u as He,g as Ve,f as ze}from"./main-c549d78a.js";import{S as Ke}from"./Sponsor-42fdf76b.js";import{g as Ye}from"./generate_filename-73dd8043.js";const qe=134227968,me=16384;function Fe(r,e){let a=0;for(;a<r.data.length&&e>=r.data[a].address+r.data[a].bytes;a++);const o={lineIndex:a};return r.data[a]&&e>=r.data[a].address&&(o.byteIndex=e-r.data[a].address),o}function _e(r,e){let a=0;for(let o=0;o<4;o++)a+=r.data[e.lineIndex].data[e.byteIndex++]<<8*o,e.byteIndex>=r.data[e.lineIndex].bytes&&(e.lineIndex++,e.byteIndex=0);return a}function Xe(r){const e={},a=Fe(r,qe);if(a.byteIndex!==void 0)return e.startAddress=_e(r,a),e.endAddress=_e(r,a),e}function We(r,e,a){let o=a;const n=Fe(r,o);if(n.byteIndex!==void 0)throw new Error("Configuration area in firmware not free.");let c=0;for(;c<e.length;){const u=e.length-c,p={address:o,bytes:me>u?u:me,data:[]};if(r.data[n.lineIndex]&&p.address+p.bytes>r.data[n.lineIndex].address)throw new Error("Aborting data generation, free area too small.");for(let h=0;h<p.bytes;h++)p.data.push(e.charCodeAt(c++));o=o+p.bytes,r.data.splice(n.lineIndex++,0,p)}r.bytes_total+=e.length}const be="Custom defaults inserted in";class je{insertConfig(e,a){console.time(be);const o=`# Betaflight
${a}\0`,n=Xe(e);if(!n||n.endAddress-n.startAddress===0)return!1;if(o.length>=n.endAddress-n.startAddress)throw new Error(`Custom defaults area too small (${n.endAddress-n.startAddress} bytes), ${o.length+1} bytes needed.`);return We(e,o,n.startAddress),console.timeEnd(be),!0}}const ve="HEX_PARSER - File parsed in";async function Je(r){console.time(ve),r=r.split(`
`),r[r.length-1]==""&&r.pop();let e=!0;const a={data:[],end_of_file:!1,bytes_total:0,start_linear_address:0};let o=0,n=0;for(let c=0;c<r.length&&e;c++){const u=parseInt(r[c].substr(1,2),16),p=parseInt(r[c].substr(3,4),16),h=parseInt(r[c].substr(7,2),16),b=r[c].substr(9,u*2),x=parseInt(r[c].substr(9+u*2,2),16);switch(h){case 0:{(p!==n||n===0)&&a.data.push({address:o+p,bytes:0,data:[]}),n=p+u;let T=u+parseInt(r[c].substr(3,2),16)+parseInt(r[c].substr(5,2),16)+h;for(let O=0;O<u*2;O+=2){const y=parseInt(b.substr(O,2),16),R=a.data.length-1;a.data[R].data.push(y),a.data[R].bytes++,T+=y,a.bytes_total++}T=~T+1&255,T!=x&&(e=!1);break}case 1:a.end_of_file=!0;break;case 2:parseInt(b,16)!=0&&console.log("extended segment address record found - NOT IMPLEMENTED !!!");break;case 3:parseInt(b,16)!=0&&console.log("start segment address record found - NOT IMPLEMENTED !!!");break;case 4:o=(parseInt(b.substr(0,2),16)<<24|parseInt(b.substr(2,2),16)<<16)>>>0;break;case 5:a.start_linear_address=parseInt(b,16);break}}return console.timeEnd(ve),a.end_of_file&&e?a:null}const P=Ne();function oe(r){Ee(r.detail.buffer)}function Qe(){P.disconnect(r=>{console.log("Disconnected",r),F.clearListeners(),this.onTimeoutCallback()}),F.disconnect_cleanup()}class Ze{constructor(){this.baud=void 0,this.port=void 0,this.onConnectCallback=void 0,this.onTimeoutCallback=void 0,this.onDisconnectCallback=void 0}handleConnect(e){if(e){A.resetState(),m.timeout_add("msp_connector",function(){ue.connectionValid||(L(l.getMessage("noConfigurationReceived")),Qe())},1e4),P.removeEventListener("receive",oe),P.addEventListener("receive",oe);const a=new xe;F.listen(a.process_data.bind(a)),F.send_message(B.MSP_API_VERSION,!1,!1,()=>{ue.connectionValid=!0,m.timeout_remove("msp_connector"),console.log("Connected"),this.onConnectCallback()})}else L(l.getMessage("serialPortOpenFail")),this.onFailureCallback()}handleDisconnect(e){console.log("Disconnected",e),P.removeEventListener("receive",oe),P.removeEventListener("connect",a=>this.handleConnect(a.detail)),P.removeEventListener("disconnect",a=>this.handleDisconnect(a)),F.clearListeners(),F.disconnect_cleanup()}connect(e,a,o,n,c){this.port=e,this.baud=a,this.onConnectCallback=o,this.onTimeoutCallback=n,this.onFailureCallback=c,P.removeEventListener("connect",u=>this.handleConnect(u.detail)),P.addEventListener("connect",u=>this.handleConnect(u.detail),{once:!0}),P.removeEventListener("disconnect",u=>this.handleDisconnect(u)),P.addEventListener("disconnect",u=>this.handleDisconnect(u),{once:!0}),P.connect(this.port,{baudRate:this.baud})}disconnect(e){this.onDisconnectCallback=e,P.disconnect(a=>{F.clearListeners(),console.log("Disconnected",a),this.onDisconnectCallback(a)}),F.disconnect_cleanup()}}function Se(r){Ee(r.detail.buffer)}function et(){m.connect_lock=!1,console.log("Looking for capabilities via MSP failed"),f.firmware_flasher.flashingMessage(l.getMessage("stm32RebootingToBootloaderFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID)}function tt(){m.connect_lock=!1,f.firmware_flasher.refresh()}class st{constructor(){this.baud=null,this.options={},this.callback=null,this.hex=null,this.verify_hex=[],this.receive_buffer=[],this.bytesToRead=0,this.read_callback=null,this.upload_time_start=0,this.upload_process_alive=!1,this.mspConnector=new Ze,this.status={ACK:121,NACK:31},this.command={get:0,get_ver_r_protect_s:1,get_ID:2,read_memory:17,go:33,write_memory:49,erase:67,extended_erase:68,write_protect:99,write_unprotect:115,readout_protect:130,readout_unprotect:146},this.available_flash_size=0,this.page_size=0,this.useExtendedErase=!1,this.rebootMode=0,this.handleMSPConnect=this.handleMSPConnect.bind(this)}handleConnect(e){console.log("Connected to serial port",e.detail,e),e?(m.connect_lock=!0,this.initialize()):L(l.getMessage("serialPortOpenFail"))}handleDisconnect(e){console.log("Waiting for DFU connection"),g.removeEventListener("connect",a=>this.handleConnect(a.detail)),g.removeEventListener("disconnect",a=>this.handleDisconnect(a.detail)),e&&this.rebootMode?setTimeout(()=>{this.rebootMode&&(console.log("STM32 Requesting permission for device"),z.requestPermission().then(a=>{a!=null?console.log("DFU request permission granted",a):(console.error("DFU request permission denied"),this.rebootMode=0,m.connect_lock=!1)}).catch(a=>{console.error("DFU request permission failed",a),this.rebootMode=0,m.connect_lock=!1}))},3e3):m.connect_lock=!1}prepareSerialPort(){g.removeEventListener("connect",e=>this.handleConnect(e.detail)),g.addEventListener("connect",e=>this.handleConnect(e.detail),{once:!0}),g.removeEventListener("disconnect",e=>this.handleDisconnect(e.detail)),g.addEventListener("disconnect",e=>this.handleDisconnect(e.detail),{once:!0})}reboot(){const e=[];e.push8(this.rebootMode),setTimeout(()=>{F.promise(B.MSP_SET_REBOOT,e).then(()=>{this.mspConnector.disconnect(a=>{console.log("Disconnecting from MSP",a),this.handleDisconnect(a)})}),console.log("Reboot request received by device")},100)}onAbort(){m.connect_lock=!1,this.rebootMode=0,console.log("User cancelled because selected target does not match verified board"),this.reboot(),f.firmware_flasher.refresh()}lookingForCapabilitiesViaMSP(){console.log("Looking for capabilities via MSP"),F.promise(B.MSP_BOARD_INFO).then(()=>{Ue(A.CONFIG.targetCapabilities,A.TARGET_CAPABILITIES_FLAGS.HAS_FLASH_BOOTLOADER)?(L(l.getMessage("deviceRebooting_flashBootloader")),console.log("flash bootloader detected"),this.rebootMode=4):(L(l.getMessage("deviceRebooting_romBootloader")),console.log("no flash bootloader detected"),this.rebootMode=1);const e=f.firmware_flasher.selectedBoard!=="0"?f.firmware_flasher.selectedBoard:"NONE",a=A.CONFIG.boardName?A.CONFIG.boardName:"UNKNOWN";try{e!==a&&!f.firmware_flasher.localFirmwareLoaded?f.firmware_flasher.showDialogVerifyBoard(e,a,this.reboot.bind(this),this.onAbort.bind(this)):this.reboot()}catch(o){console.error(o),this.reboot()}})}handleMSPConnect(){L(l.getMessage("apiVersionReceived",[A.CONFIG.apiVersion])),this.lookingForCapabilitiesViaMSP()}connect(e,a,o,n,c){this.hex=o,this.port=e,this.baud=a,this.callback=c,this.serialOptions=n,this.mspOptions={no_reboot:!1,reboot_baud:!1,erase_chip:!1},n.no_reboot?this.mspOptions.no_reboot=!0:this.mspOptions.reboot_baud=n.reboot_baud,n.erase_chip&&(this.mspOptions.erase_chip=!0),this.options.no_reboot?(this.prepareSerialPort(),g.connect(e,{baudRate:this.baud,parityBit:"even",stopBits:"one"})):(this.rebootMode=0,m.connect_lock=!0,f.firmware_flasher.flashingMessage(l.getMessage("stm32RebootingToBootloader"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),g.addEventListener("disconnect",u=>this.handleDisconnect(u.detail),{once:!0}),this.mspConnector.connect(this.port,this.mspOptions.reboot_baud,this.handleMSPConnect,et,tt))}initialize(){console.log(":exploding_head:"),this.receive_buffer=[],this.verify_hex=[],this.upload_time_start=new Date().getTime(),this.upload_process_alive=!1,f.firmware_flasher.flashingMessage(null,f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL).flashProgress(0),t('select[name="release"]').prop("disabled",!0),g.removeEventListener("receive",Se),g.addEventListener("receive",Se),m.interval_add("STM32_timeout",()=>{this.upload_process_alive?this.upload_process_alive=!1:(console.log("STM32 - timed out, programming failed ..."),f.firmware_flasher.flashingMessage(l.getMessage("stm32TimedOut"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),m.interval_remove("STM32_timeout"),this.upload_procedure(99))},2e3),console.log("STM32 - Initialization done, starting upload procedure"),this.upload_procedure(1)}read(e){const a=new Uint8Array(e.data);for(const o of a)this.receive_buffer.push(o);if(this.receive_buffer.length>=this.bytesToRead&&this.bytesToRead!=0){const o=this.receive_buffer.slice(0,this.bytesToRead);this.receive_buffer.splice(0,this.bytesToRead),this.bytesToRead=0,this.read_callback(o)}}retrieve(e,a){if(this.receive_buffer.length>=e){const o=this.receive_buffer.slice(0,e);this.receive_buffer.splice(0,e),a(o)}else this.bytesToRead=e,this.read_callback=a}send(e,a,o){this.upload_process_alive=!0;const n=new ArrayBuffer(e.length);new Uint8Array(n).set(e),this.bytesToRead=a,this.read_callback=o,this.receive_buffer=[],g.send(n)}verify_response(e,a){if(e!==a[0]){const o=`STM32 Communication failed, wrong response, expected: ${e} (0x${e.toString(16)}) received: ${a[0]} (0x${a[0].toString(16)})`;return console.error(o),f.firmware_flasher.flashingMessage(l.getMessage("stm32WrongResponse",[e,e.toString(16),a[0],a[0].toString(16)]),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),this.upload_procedure(99),!1}return!0}verify_chip_signature(e){switch(e){case 1042:console.log("Chip recognized as F1 Low-density");break;case 1040:console.log("Chip recognized as F1 Medium-density"),this.available_flash_size=131072,this.page_size=1024;break;case 1044:this.available_flash_size=262144,this.page_size=2048,console.log("Chip recognized as F1 High-density");break;case 1048:console.log("Chip recognized as F1 Connectivity line");break;case 1056:console.log("Chip recognized as F1 Medium-density value line");break;case 1064:console.log("Chip recognized as F1 High-density value line");break;case 1072:console.log("Chip recognized as F1 XL-density value line");break;case 1046:console.log("Chip recognized as L1 Medium-density ultralow power");break;case 1078:console.log("Chip recognized as L1 High-density ultralow power");break;case 1063:console.log("Chip recognized as L1 Medium-density plus ultralow power");break;case 1041:console.log("Chip recognized as F2 STM32F2xxxx");break;case 1088:console.log("Chip recognized as F0 STM32F051xx");break;case 1092:console.log("Chip recognized as F0 STM32F050xx");break;case 1043:console.log("Chip recognized as F4 STM32F40xxx/41xxx");break;case 1049:console.log("Chip recognized as F4 STM32F427xx/437xx, STM32F429xx/439xx");break;case 1074:console.log("Chip recognized as F3 STM32F37xxx, STM32F38xxx");break;case 1058:console.log("Chip recognized as F3 STM32F30xxx, STM32F31xxx"),this.available_flash_size=262144,this.page_size=2048;break;default:console.log(`Chip NOT recognized: ${e}`);break}return this.available_flash_size>0?this.hex.bytes_total<this.available_flash_size?!0:(console.log(`Supplied hex is bigger then flash available on the chip, HEX: ${this.hex.bytes_total} bytes, limit = ${this.available_flash_size} bytes`),!1):(console.log(`Chip NOT recognized: ${e}`),!1)}verify_flash(e,a){for(let o=0;o<e.length;o++)if(e[o]!==a[o])return console.log(`Verification failed on byte: ${o} expected: 0x${e[o].toString(16)} received: 0x${a[o].toString(16)}`),!1;return console.log(`Verification successful, matching: ${e.length} bytes`),!0}upload_procedure(e){switch(e){case 1:{f.firmware_flasher.flashingMessage(l.getMessage("stm32ContactingBootloader"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);let a=0;m.interval_add("stm32_initialize_mcu",()=>{this.send([127],1,o=>{o[0]===127||o[0]===this.status.ACK||o[0]===this.status.NACK?(m.interval_remove("stm32_initialize_mcu"),console.log("STM32 - Serial interface initialized on the MCU side"),this.upload_procedure(2)):(f.firmware_flasher.flashingMessage(l.getMessage("stm32ContactingBootloaderFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),m.interval_remove("stm32_initialize_mcu"),this.upload_procedure(99))}),a++>3&&(console.log("STM32 - no response from bootloader, disconnecting"),f.firmware_flasher.flashingMessage(l.getMessage("stm32ResponseBootloaderFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),m.interval_remove("stm32_initialize_mcu"),m.interval_remove("STM32_timeout"),this.upload_procedure(99))},250,!0);break}case 2:{this.send([this.command.get,255],2,a=>{this.verify_response(this.status.ACK,a)&&this.retrieve(a[1]+1+1,o=>{console.log(`STM32 - Bootloader version: ${(parseInt(o[0].toString(16))/10).toFixed(1)}`),this.useExtendedErase=o[7]===this.command.extended_erase,this.upload_procedure(3)})});break}case 3:this.send([this.command.get_ID,253],2,a=>{this.verify_response(this.status.ACK,a)&&this.retrieve(a[1]+1+1,o=>{const n=o[0]<<8|o[1];console.log(`STM32 - Signature: 0x${n.toString(16)}`),this.verify_chip_signature(n)?this.upload_procedure(4):this.upload_procedure(99)})});break;case 4:{if(this.useExtendedErase){this.options.erase_chip?(console.log("Executing global chip erase (via extended erase)"),f.firmware_flasher.flashingMessage(l.getMessage("stm32GlobalEraseExtended"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.extended_erase,187],1,o=>{this.verify_response(this.status.ACK,o)&&this.send([255,255,0],1,n=>{this.verify_response(this.status.ACK,n)&&(console.log("Executing global chip extended erase: done"),this.upload_procedure(5))})})):(console.log("Executing local erase (via extended erase)"),f.firmware_flasher.flashingMessage(l.getMessage("stm32LocalEraseExtended"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.extended_erase,187],1,o=>{if(this.verify_response(this.status.ACK,o)){const n=this.hex.data[this.hex.data.length-1].address+this.hex.data[this.hex.data.length-1].bytes-134217728,c=Math.ceil(n/this.page_size),u=[];let p=0,h;h=c-1>>8,u.push(h),p^=h,h=c-1&255,u.push(h),p^=h;for(let b=0;b<c;b++)h=b>>8,u.push(h),p^=h,h=b&255,u.push(h),p^=h;u.push(p),console.log(`Erasing. pages: 0x00 - 0x${c.toString(16)}, checksum: 0x${p.toString(16)}`),this.send(u,1,b=>{this.verify_response(this.status.ACK,b)&&(console.log("Erasing: done"),this.upload_procedure(5))})}}));break}this.options.erase_chip?(console.log("Executing global chip erase"),f.firmware_flasher.flashingMessage(l.getMessage("stm32GlobalErase"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.erase,188],1,o=>{this.verify_response(this.status.ACK,o)&&this.send([255,0],1,n=>{this.verify_response(this.status.ACK,n)&&(console.log("Erasing: done"),this.upload_procedure(5))})})):(console.log("Executing local erase"),f.firmware_flasher.flashingMessage(l.getMessage("stm32LocalErase"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL),this.send([this.command.erase,188],1,o=>{if(this.verify_response(this.status.ACK,o)){const n=this.hex.data[this.hex.data.length-1].address+this.hex.data[this.hex.data.length-1].bytes-134217728,c=Math.ceil(n/this.page_size),u=[];let p=c-1;u.push(c-1);for(let h=0;h<c;h++)u.push(h),p^=h;u.push(p),this.send(u,1,h=>{this.verify_response(this.status.ACK,h)&&(console.log("Erasing: done"),this.upload_procedure(5))})}}));break}case 5:{console.log("Writing data ..."),f.firmware_flasher.flashingMessage(l.getMessage("stm32Flashing"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);let a=this.hex.data.length-1,o=0,n=this.hex.data[o].address,c=0,u=0;const p=()=>{if(c<this.hex.data[o].bytes){const h=c+256<=this.hex.data[o].bytes?256:this.hex.data[o].bytes-c;this.send([this.command.write_memory,206],1,b=>{if(this.verify_response(this.status.ACK,b)){const x=[n>>24,n>>16,n>>8,n],T=x[0]^x[1]^x[2]^x[3];this.send([x[0],x[1],x[2],x[3],T],1,O=>{if(this.verify_response(this.status.ACK,O)){const y=Array.from(h+2);y[0]=h-1;let R=y[0];for(let I=0;I<h;I++)y[I+1]=this.hex.data[o].data[c],R^=this.hex.data[o].data[c],c++;y[y.length-1]=R,n+=h,u+=h,this.send(y,1,I=>{this.verify_response(this.status.ACK,I)&&p()}),f.firmware_flasher.flashProgress(Math.round(u/(this.hex.bytes_total*2)*100))}})}})}else o<a?(o++,n=this.hex.data[o].address,c=0,p()):(console.log("Writing: done"),this.upload_procedure(6))};p();break}case 6:{console.log("Verifying data ..."),f.firmware_flasher.flashingMessage(l.getMessage("stm32Verifying"),f.firmware_flasher.FLASH_MESSAGE_TYPES.NEUTRAL);const a=this.hex.data.length-1;let o=0,n=this.hex.data[o].address,c=0,u=0;for(let h=0;h<=a;h++)this.verify_hex.push([]);const p=()=>{if(c<this.hex.data[o].bytes){const h=c+256<=this.hex.data[o].bytes?256:this.hex.data[o].bytes-c;this.send([this.command.read_memory,238],1,b=>{if(this.verify_response(this.status.ACK,b)){const x=[n>>24,n>>16,n>>8,n],T=x[0]^x[1]^x[2]^x[3];this.send([x[0],x[1],x[2],x[3],T],1,O=>{if(this.verify_response(this.status.ACK,O)){const y=h-1;this.send([y,~y&255],1,R=>{this.verify_response(this.status.ACK,R)&&this.retrieve(h,I=>{for(const U of I)this.verify_hex[o].push(U);n+=h,c+=h,u+=h,p()})}),f.firmware_flasher.flashProgress(Math.round((this.hex.bytes_total+u)/(this.hex.bytes_total*2)*100))}})}})}else if(o<a)o++,n=this.hex.data[o].address,c=0,p();else{let h=!0;for(let b=0;b<=a&&(h=this.verify_flash(this.hex.data[b].data,this.verify_hex[b]),!!h);b++);h?(console.log("Programming: SUCCESSFUL"),f.firmware_flasher.flashingMessage(l.getMessage("stm32ProgrammingSuccessful"),f.firmware_flasher.FLASH_MESSAGE_TYPES.VALID),D("showNotifications").showNotifications&&pe.showNotification("Betaflight Configurator",{body:l.getMessage("programmingSuccessfulNotification"),icon:"/images/pwa/favicon.ico"}),this.upload_procedure(7)):(console.log("Programming: FAILED"),f.firmware_flasher.flashingMessage(l.getMessage("stm32ProgrammingFailed"),f.firmware_flasher.FLASH_MESSAGE_TYPES.INVALID),D("showNotifications").showNotifications&&pe.showNotification("Betaflight Configurator",{body:l.getMessage("programmingFailedNotification"),icon:"/images/pwa/favicon.ico"}),this.upload_procedure(99))}};p();break}case 7:{console.log("Sending GO command: 0x8000000"),this.send([this.command.go,222],1,a=>{if(this.verify_response(this.status.ACK,a)){const n=[8,2048,524288,134217728],c=n[0]^n[1]^n[2]^n[3];this.send([n[0],n[1],n[2],n[3],c],1,u=>{this.verify_response(this.status.ACK,u)&&this.upload_procedure(99)})}});break}case 99:{m.interval_remove("STM32_timeout"),g.connectionId?g.disconnect(this.cleanup):this.cleanup();break}}}cleanup(){$e.reset(),m.connect_lock=!1,t('select[name="release"]').prop("disabled",!1);const e=new Date().getTime()-this.upload_time_start;console.log(`Script finished after: ${e/1e3} seconds`),this.callback&&this.callback()}}const Z=new st;class at{constructor(){this.outputHistory="",this.callback=null}handleConnect(e){console.log("Connected to serial port:",e),e?(g.removeEventListener("receive",this.readSerialAdapter),g.addEventListener("receive",this.readSerialAdapter.bind(this)),this.run()):L(l.getMessage("serialPortOpenFail"))}handleDisconnect(e){L(l.getMessage(e.detail?"serialPortClosedOk":"serialPortClosedFail")),g.removeEventListener("receive",this.readSerialAdapter),g.removeEventListener("connect",this.handleConnect),g.removeEventListener("disconnect",this.handleDisconnect)}readSerialAdapter(e){const a=new Uint8Array(e.detail.buffer);for(const o of a){const n=String.fromCharCode(o);this.outputHistory+=n}}onClose(){g.addEventListener("disconnect",this.handleDisconnect.bind(this),{once:!0}),g.disconnect()}async save(e){console.log("Saving backup");const a="cli_backup",o="txt",n=Ye(a,o);K.pickSaveFile(n,l.getMessage("fileSystemPickerFiles",{types:o.toUpperCase()}),`.${o}`).then(c=>{console.log("Saving config to:",c.name),K.writeFile(c,e)}).catch(c=>{console.error("Error saving config:",c)}).finally(()=>{this.callback&&this.callback()})}async run(){console.log("Running backup"),await this.activateCliMode(),await this.sendCommand("diff all"),setTimeout(async()=>{this.sendCommand("exit",this.onClose);const e=this.outputHistory.split(`
`).slice(1).join(`
`);await this.save(e)},1500)}async activateCliMode(){return new Promise(e=>{const a=new ArrayBuffer(1),o=new Uint8Array(a);o[0]=35,g.send(a),setTimeout(()=>{this.outputHistory="",e()},500)})}async sendSerial(e,a){const o=new ArrayBuffer(e.length),n=new Uint8Array(o);for(let c=0;c<e.length;c++)n[c]=e.charCodeAt(c);g.send(o,a)}async sendCommand(e,a){this.sendSerial(`${e}
`,a)}execute(e){this.callback=e;const a=V.portPicker.selectedPort,o=V.portPicker.selectedBauds;a.startsWith("serial")?(g.addEventListener("connect",this.handleConnect.bind(this),{once:!0}),g.connect(a,{baudRate:o})):L(l.getMessage("firmwareFlasherNoPortSelected"))}}const ot=new at;let W=null;function ie(r){F.read(r.detail.buffer)}class it{constructor(){this.board=A.CONFIG.boardName,this.targetAvailable=!1}verifyBoard(){const e=V.portPicker.selectedPort;if(!(f.firmware_flasher.targets?Object.keys(f.firmware_flasher.targets).length>0:!1)){console.log("Releases not loaded yet"),L(l.getMessage("firmwareFlasherNoTargetsLoaded"));return}if(g.connected||g.connectionId){console.warn("Attempting to connect while there still is a connection",g.connected,g.connectionId,g.openCanceled),g.disconnect();return}L(l.getMessage("firmwareFlasherDetectBoardQuery")),g.addEventListener("connect",this.handleConnect.bind(this),{once:!0}),g.addEventListener("disconnect",this.handleDisconnect.bind(this),{once:!0}),e.startsWith("serial")&&g.connect(e,{baudRate:115200})}handleConnect(e){this.onConnect(e.detail)}handleDisconnect(e){this.onClosed(e.detail)}onClosed(e){L(l.getMessage(e?"serialPortClosedOk":"serialPortClosedFail")),this.targetAvailable||L(l.getMessage("firmwareFlasherBoardVerificationFail")),F.clearListeners(),g.removeEventListener("receive",ie),g.removeEventListener("connect",this.handleConnect.bind(this)),g.removeEventListener("disconnect",this.handleDisconnect.bind(this))}onFinishClose(){const e=A.CONFIG.boardName;if(e){const a=$('select[name="board"]'),o=$('select[name="board"] option'),n=a.val();o.each((c,u)=>{$(u).text()===e&&(this.targetAvailable=!0)}),e!==n&&a.val(e).trigger("change"),L(l.getMessage(this.targetAvailable?"firmwareFlasherBoardVerificationSuccess":"firmwareFlasherBoardVerficationTargetNotAvailable",{boardName:e}))}g.disconnect(this.onClosed),F.disconnect_cleanup()}async getBoardInfo(){await F.promise(B.MSP_BOARD_INFO),j.gte(A.CONFIG.apiVersion,ge)&&(A.processBuildOptions(),f.firmware_flasher.cloudBuildOptions=A.CONFIG.buildOptions),this.onFinishClose()}async getCloudBuildOptions(e){f.firmware_flasher.cloudBuildOptions=e.Request.Options,await this.getBoardInfo()}async getBuildInfo(){if(j.gte(A.CONFIG.apiVersion,De)&&A.CONFIG.flightControllerIdentifier==="BTFL"){await F.promise(B.MSP2_GET_TEXT,W.crunch(B.MSP2_GET_TEXT,B.BUILD_KEY)),await F.promise(B.MSP2_GET_TEXT,W.crunch(B.MSP2_GET_TEXT,B.CRAFT_NAME)),await F.promise(B.MSP_BUILD_INFO),f.firmware_flasher.cloudBuildKey=A.CONFIG.buildKey;const e=new Date("3/21/2024"),a=new Date(A.CONFIG.buildInfo);if(f.firmware_flasher.validateBuildKey()&&(j.lt(A.CONFIG.apiVersion,ge)||a<e))return f.firmware_flasher.buildApi.requestBuildOptions(f.firmware_flasher.cloudBuildKey,this.getCloudBuildOptions.bind(this),this.getBoardInfo.bind(this))}await this.getBoardInfo()}async requestBoardInformation(){await F.promise(B.MSP_API_VERSION),L(l.getMessage("apiVersionReceived",A.CONFIG.apiVersion)),A.CONFIG.apiVersion.includes("null")||j.lt(A.CONFIG.apiVersion,"1.39.0")?this.onFinishClose():(await F.promise(B.MSP_FC_VARIANT),await this.getBuildInfo())}onConnect(e){e?(g.removeEventListener("receive",ie),g.addEventListener("receive",ie),W=new xe,F.listen(W.process_data.bind(W)),this.requestBoardInformation()):L(l.getMessage("serialPortOpenFail"))}}const nt=new it,M={targets:null,buildApi:new Ge,sponsor:new Ke,localFirmwareLoaded:!1,selectedBoard:void 0,cloudBuildKey:null,cloudBuildOptions:null,isFlashing:!1,intel_hex:void 0,parsed_hex:void 0,isConfigLocal:!1,filename:null,configFilename:null,config:{},developmentFirmwareLoaded:!1,cancelBuild:!1};M.initialize=function(r){const e=this;m.active_tab!=="firmware_flasher"&&(m.active_tab="firmware_flasher"),e.selectedBoard=void 0,e.cloudBuildKey=null,e.cloudBuildOptions=null,e.localFirmwareLoaded=!1,e.isConfigLocal=!1,e.intel_hex=void 0,e.parsed_hex=void 0;function a(){function o(s,i){Je(s).then(d=>{i(d)})}function n(s){var i,d;e.filename=s,e.localFirmwareLoaded?e.flashingMessage(l.getMessage("firmwareFlasherFirmwareLocalLoaded",{filename:s,bytes:e.parsed_hex.bytes_total}),e.FLASH_MESSAGE_TYPES.NEUTRAL):e.flashingMessage(`<a class="save_firmware" href="#" title="Save Firmware">${l.getMessage("firmwareFlasherFirmwareOnlineLoaded",{filename:s,bytes:e.parsed_hex.bytes_total})}</a>`,e.FLASH_MESSAGE_TYPES.NEUTRAL),e.enableFlashButton(!0),N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"FirmwareLoaded",{firmwareSize:e.parsed_hex.bytes_total,firmwareName:s,firmwareSource:e.localFirmwareLoaded?"file":"http",selectedTarget:(i=e.targetDetail)==null?void 0:i.target,selectedRelease:(d=e.targetDetail)==null?void 0:d.release})}function c(s){s.manufacturer?(t("div.release_info #manufacturer").text(s.manufacturer),t("div.release_info #manufacturerInfo").show()):t("div.release_info #manufacturerInfo").hide(),t("div.release_info .target").text(s.target),t("div.release_info .name").text(s.release).prop("href",s.releaseUrl),t("div.release_info .date").text(s.date),t("div.release_info #targetMCU").text(s.mcu),t("div.release_info .configFilename").text(e.isConfigLocal?e.configFilename:"[default]"),s.cloudBuild?(t("div.release_info #cloudTargetInfo").show(),t("div.release_info #cloudTargetLog").text(""),t("div.release_info #cloudTargetStatus").text("pending")):t("div.release_info #cloudTargetInfo").hide(),e.targets&&(t("div.release_info").slideDown(),t(".tab-firmware_flasher .content_wrapper").animate({scrollTop:t("div.release_info").position().top},1e3))}function u(){e.config={},e.isConfigLocal=!1,e.configFilename=null}function p(s,i){e.config=s.join(`
`),e.isConfigLocal=i!==void 0,e.configFilename=i!==void 0?i:null}function h(s,i){e.intel_hex=s,o(e.intel_hex,function(d){e.parsed_hex=d,e.parsed_hex?n(i):(e.flashingMessage(l.getMessage("firmwareFlasherHexCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID),e.enableFlashButton(!1))})}function b(s,i){e.localFirmwareLoaded=!1,h(s,i),e.enableLoadRemoteFileButton(!0),t("a.load_remote_file").text(l.getMessage("firmwareFlasherButtonLoadOnline"))}function x(s){if(!s||!ne()){t('select[name="board"]').empty().append('<option value="0">Offline</option>'),t('select[name="firmware_version"]').empty().append('<option value="0">Offline</option>');return}const i=t('select[name="board"]');i.empty(),i.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectBoard")}</option>`));const d=t('select[name="firmware_version"]');d.empty(),d.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersion")}</option>`)),Object.keys(s).sort((_,C)=>_.target-C.target).forEach(function(_,C){const S=s[_],E=t(`<option value='${S.target}'>${S.target}</option>`);i.append(E)}),f.firmware_flasher.targets=s,t("div.build_configuration").slideUp()}function T(s,i){s.empty(),i.forEach(d=>{d.default?s.append(t(`<option value='${d.value}' selected>${d.name}</option>`)):s.append(t(`<option value='${d.value}'>${d.name}</option>`))})}function O(){const s=t('select[name="radioProtocols"] option:selected').val(),i=["USE_SERIALRX_CRSF","USE_SERIALRX_FPORT","USE_SERIALRX_GHST","USE_SERIALRX_JETIEXBUS"].includes(s);t('select[name="telemetryProtocols"]').attr("disabled",i),i?t('select[name="telemetryProtocols"] option[value="-1"]').length===0?t('select[name="telemetryProtocols"]').prepend(t("<option>",{value:"-1",selected:"selected",text:l.getMessage("firmwareFlasherOptionLabelTelemetryProtocolIncluded")})):t('select[name="telemetryProtocols"] option:first').attr("selected","selected").text(l.getMessage("firmwareFlasherOptionLabelTelemetryProtocolIncluded")):t('select[name="telemetryProtocols"] option[value="-1"]').length&&t('select[name="telemetryProtocols"] option:first').remove()}function y(s){ne()&&(s.osdProtocols=s.generalOptions.filter(i=>i.group==="OSD").map(i=>{var d;return i.name=i.groupedName,i.default=(d=e.cloudBuildOptions)==null?void 0:d.includes(i.value),i}),s.osdProtocols.unshift({name:"None",value:""}),s.generalOptions=s.generalOptions.filter(i=>!i.group),T(t('select[name="radioProtocols"]'),s.radioProtocols),T(t('select[name="telemetryProtocols"]'),s.telemetryProtocols),T(t('select[name="osdProtocols"]'),s.osdProtocols),T(t('select[name="options"]'),s.generalOptions),T(t('select[name="motorProtocols"]'),s.motorProtocols),e.validateBuildKey()||R(),O())}function R(){const s=D("ffRadioProtocol").ffRadioProtocol;s&&t('select[name="radioProtocols"] option').filter(function(d,_){return _.value===s}).length!==0&&t('select[name="radioProtocols"]').val(s)}let I;const U=t('select[name="build_type"]');function we(){U.empty(),I.forEach(({tag:s,title:i},d)=>{U.append(t(`<option value='${d}'>${s?l.getMessage(s):i}</option>`))})}const re=[{tag:"firmwareFlasherOptionLabelBuildTypeRelease"},{tag:"firmwareFlasherOptionLabelBuildTypeReleaseCandidate"},{tag:"firmwareFlasherOptionLabelBuildTypeDevelopment"}];function Ae(){t(this).is(":checked")?t("tr.build_type").show():(t("tr.build_type").hide(),U.val(0).trigger("change"))}function Ce(){const s=t(this).is(":checked");s?I=re:I=re.slice(0,2),we(),U.val(0).trigger("change"),setTimeout(()=>{t("tr.expertOptions").toggle(s),t("div.expertOptions").toggle(s)},0),H({expertMode:s})}const Y=t(".tab-firmware_flasher input.expert_mode"),Le=D("expertMode").expertMode;Y.prop("checked",Le),Y.on("change",Ce).trigger("change"),t("input.show_development_releases").change(Ae).change(),l.localizePage(),e.sponsor.loadSponsorTile("flash",t("div.tab_sponsor")),U.on("change",function(){e.enableLoadRemoteFileButton(!1);const s=U.val();if(t('select[name="board"]').empty().append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLoading")}</option>`)),t('select[name="firmware_version"]').empty().append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLoading")}</option>`)),!m.connect_lock)try{e.buildApi.loadTargets(x)}catch(i){console.error(i)}H({selected_build_type:s})});function le(s){t("div.build_configuration").slideUp(),t("div.release_info").slideUp(),e.localFirmwareLoaded||(e.enableFlashButton(!1),e.flashingMessage(l.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL),e.parsed_hex&&e.parsed_hex.bytes_total&&(console.log("throw out loaded hex"),e.intel_hex=void 0,e.parsed_hex=void 0));const i=t('select[name="board"] option:selected').val();function d(C){if(e.targetDetail=C,C.cloudBuild===!0){t("div.build_configuration").slideDown();const S=Y.is(":checked");S&&(C.releaseType==="Unstable"?(e.buildApi.loadCommits(C.release,E=>{const v=t('select[name="commits"]');v.empty(),E.forEach(G=>{v.append(t(`<option value='${G.sha}'>${G.message.split(`
`)[0]}</option>`))})}),t("div.commitSelection").show()):t("div.commitSelection").hide()),t("div.expertOptions").toggle(S),t("input.corebuild_mode").trigger("change")}C.configuration&&!e.isConfigLocal&&p(C.configuration),e.enableLoadRemoteFileButton(!0)}e.buildApi.loadTarget(i,s,d);const _=()=>e.buildApi.loadOptions(s,y);e.validateBuildKey()?e.buildApi.loadOptionsByBuildKey(s,e.cloudBuildKey,y,_):_()}function ye(s,i){const d=function(C,S){return-j.compareBuild(C.release,S.release)};s.empty();const _=i.releases;if(_.length>0){s.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersionFor")} ${i.target}</option>`));const C=t('select[name="build_type"]').val();_.sort(d).filter(S=>S.type==="Unstable"&&C>1||S.type==="ReleaseCandidate"&&C>0||S.type==="Stable").forEach(function(S){const E=S.release,v=t(`<option value='${E}'>${E} [${S.label}]</option>`),G=`${i}/${S}`;v.data("summary",G),s.append(v)}),s.prop("selectedIndex",1),le(s.val())}}function ce(){u(),e.intel_hex=void 0,e.parsed_hex=void 0,e.localFirmwareLoaded=!1}t('select[name="board"]').select2(),t('select[name="osdProtocols"]').select2(),t('select[name="radioProtocols"]').select2(),t('select[name="telemetryProtocols"]').select2(),t('select[name="motorProtocols"]').select2(),t('select[name="options"]').select2({tags:!1,closeOnSelect:!1}),t('select[name="commits"]').select2({tags:!0}),t('select[name="options"]').on("select2:opening",function(){t(this).parent().find(".select2-search__field").prop("disabled",!1)}).on("select2:closing",function(){t(this).parent().find(".select2-search__field").prop("disabled",!0)}),t('select[name="radioProtocols"]').on("select2:select",function(){const s=t('select[name="radioProtocols"] option:selected').first().val();s&&H({ffRadioProtocol:s}),O()}),t('select[name="board"]').on("change",function(){e.enableLoadRemoteFileButton(!1);let s=t(this).val();if(s===null&&(s="0",t(this).val(s).trigger("change")),!m.connect_lock){e.selectedBoard=s,console.log("board changed to",s),e.flashingMessage(l.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL).flashProgress(0),t("div.release_info").slideUp(),t("div.build_configuration").slideUp(),e.localFirmwareLoaded||e.enableFlashButton(!1);const i=t('select[name="firmware_version"]');s==="0"?(ce(),i.empty(),i.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLabelSelectFirmwareVersion")}</option>`))):(i.empty(),i.append(t(`<option value='0'>${l.getMessage("firmwareFlasherOptionLoading")}</option>`)),e.buildApi.loadTargetReleases(s,d=>ye(i,d)))}});const Me=['select[name="board"]','select[name="radioProtocols"]','select[name="telemetryProtocols"]','select[name="osdProtocols"]','select[name="motorProtocols"]','select[name="options"]','select[name="commits"]'];t(document).on("select2:open",Me.join(","),()=>{const s=document.querySelectorAll(".select2-container--open .select2-search__field");t(this).one("mouseup keyup",()=>{setTimeout(()=>{s[s.length-1].focus()},0)})});function Te(s){let i=[],d=!1;for(let _=0;_<s.length;_++){if((s.charAt(_)===`
`||s.charAt(_)==="\r")&&(d=!1),s.charAt(_)==="#"&&(d=!0),!d&&s.charCodeAt(_)>255)return e.flashingMessage(l.getMessage("firmwareFlasherConfigCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID),L(l.getMessage("firmwareFlasherConfigCorruptedLogMessage")),null;s.charCodeAt(_)>255?i.push("_"):i.push(s.charAt(_))}return i.join("").split(`
`)}function ke(s){const i=t("input.flash_on_connect").is(":checked");console.log("Detected USB device:",s),console.log("Reboot mode: %s, flash on connect",Z.rebootMode,i),(Z.rebootMode||i)&&(Z.rebootMode=0,m.connect_lock=!1,J())}Re.$on("port-handler:auto-select-usb-device",ke);function Be(s){const i={};(t("input.erase_chip").is(":checked")||Y.is(":not(:checked)"))&&(i.erase_chip=!0);const d=V.portPicker.selectedPort,_=d.startsWith("serial_"),C=d.startsWith("usb_");if(console.log("Selected port:",d),C)N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"DFU Flashing",{filename:e.filename||null}),z.connect(d,s,i);else if(_){t("input.updating").is(":checked")?i.no_reboot=!0:i.reboot_baud=V.portPicker.selectedBauds;let S=115200;t("input.flash_manual_baud").is(":checked")&&(S=parseInt(t("#flash_manual_baud_rate").val())||115200),N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"Flashing",{filename:e.filename||null}),Z.connect(d,S,s,i)}else console.log("No valid port detected, asking for permissions"),z.requestPermission().then(S=>{z.connect(S.path,s,i)});e.isFlashing=!1,m.interval_resume("sponsor")}let k=D("erase_chip");t("input.erase_chip").prop("checked",k.erase_chip),t("input.erase_chip").change(function(){H({erase_chip:t(this).is(":checked")})}).change(),k=D("show_development_releases"),t("input.show_development_releases").prop("checked",k.show_development_releases).change(function(){H({show_development_releases:t(this).is(":checked")})}).change(),k=D("selected_build_type"),U.val(k.selected_build_type||0).trigger("change"),k=D("no_reboot_sequence"),k.no_reboot_sequence?(t("input.updating").prop("checked",!0),t(".flash_on_connect_wrapper").show()):t("input.updating").prop("checked",!1),t("input.updating").change(function(){const s=t(this).is(":checked");s?t(".flash_on_connect_wrapper").show():(t("input.flash_on_connect").prop("checked",!1).change(),t(".flash_on_connect_wrapper").hide()),H({no_reboot_sequence:s})}),t("input.updating").change(),k=D("flash_manual_baud"),k.flash_manual_baud?t("input.flash_manual_baud").prop("checked",!0):t("input.flash_manual_baud").prop("checked",!1),t("input.corebuild_mode").change(function(){const s=t(this).is(":checked");t(".hide-in-core-build-mode").toggle(!s),t("div.expertOptions").toggle(!s&&Y.is(":checked"))}),t("input.corebuild_mode").change(),t("input.flash_manual_baud").change(function(){const s=t(this).is(":checked");H({flash_manual_baud:s})}),t("input.flash_manual_baud").change(),k=D("flash_manual_baud_rate"),t("#flash_manual_baud_rate").val(k.flash_manual_baud_rate),t("#flash_manual_baud_rate").change(function(){const s=parseInt(t("#flash_manual_baud_rate").val());H({flash_manual_baud_rate:s})}),t("input.flash_manual_baud_rate").change(),t("a.load_file").on("click",function(){e.enableFlashButton(!1),e.enableLoadRemoteFileButton(!1),e.developmentFirmwareLoaded=!1,K.pickOpenFile(l.getMessage("fileSystemPickerFiles",{typeof:"HEX"}),".hex").then(s=>{console.log("Saving firmware to:",s.name),K.readFile(s).then(i=>{if(s.name.split(".").pop()==="hex")e.intel_hex=i,o(e.intel_hex,function(d){e.parsed_hex=d,e.parsed_hex?(e.localFirmwareLoaded=!0,n(s.name)):e.flashingMessage(l.getMessage("firmwareFlasherHexCorrupted"),e.FLASH_MESSAGE_TYPES.INVALID)});else{ce();let d=Te(i);d!==null&&(p(d,s.name),e.isConfigLocal&&!e.parsed_hex&&e.flashingMessage(l.getMessage("firmwareFlasherLoadedConfig"),e.FLASH_MESSAGE_TYPES.NEUTRAL),(e.isConfigLocal&&e.parsed_hex&&!e.localFirmwareLoaded||e.localFirmwareLoaded)&&(e.enableFlashButton(!0),e.flashingMessage(l.getMessage("firmwareFlasherFirmwareLocalLoaded",e.parsed_hex.bytes_total),e.FLASH_MESSAGE_TYPES.NEUTRAL)))}})}).catch(s=>{console.error("Error reading file:",s)})}),t('select[name="firmware_version"]').change(s=>{le(t("option:selected",s.target).val())}),t("a.cloud_build_cancel").on("click",function(s){t("a.cloud_build_cancel").toggleClass("disabled",!0),e.cancelBuild=!0}),t("a.load_remote_file").on("click",function(s){if(!e.selectedBoard)return;if(e.enableFlashButton(!1),e.enableLoadRemoteFileButton(!1),e.localFirmwareLoaded=!1,e.developmentFirmwareLoaded=I[t('select[name="build_type"]').val()].tag==="firmwareFlasherOptionLabelBuildTypeDevelopment",t('select[name="firmware_version"]').val()==="0"){L(l.getMessage("firmwareFlasherNoFirmwareSelected"));return}function i(){t("span.progressLabel").attr("i18n","firmwareFlasherFailedToLoadOnlineFirmware").removeClass("i18n-replaced"),e.enableLoadRemoteFileButton(!0),t("a.load_remote_file").text(l.getMessage("firmwareFlasherButtonLoadOnline")),l.localizePage()}function d(E,v,G,w){w===!0&&t("div.release_info #cloudTargetLog").text(l.getMessage("firmwareFlasherCloudBuildLogUrl")).prop("href",`https://build.betaflight.com/api/builds/${v}/log`),t("div.release_info #cloudTargetStatus").text(l.getMessage(`firmwareFlasherCloudBuild${E}`)),t(".buildProgress").val(G)}function _(E,v,G){v.status==="success"&&(d(`Success${G}`,E.key,100,!0),v.configuration!==void 0&&!e.isConfigLocal&&p(v.configuration),e.buildApi.loadTargetHex(E.url,w=>b(w,E.file),i))}function C(E,v){d(`Fail${v}`,E,0,!0),i()}function S(E){let v={target:E.target,release:E.release,options:[]};(E.cloudBuild!==!0||t('input[name="coreBuildModeCheckbox"]').is(":checked"))===!0?v.options.push("CORE_BUILD"):(v.options.push("CLOUD_BUILD"),t('select[name="radioProtocols"] option:selected').each(function(){v.options.push(t(this).val())}),t('select[name="telemetryProtocols"] option:selected').each(function(){v.options.push(t(this).val())}),t('select[name="options"] option:selected').each(function(){v.options.push(t(this).val())}),t('select[name="osdProtocols"] option:selected').each(function(){v.options.push(t(this).val())}),t('select[name="motorProtocols"] option:selected').each(function(){v.options.push(t(this).val())}),t('input[name="expertModeCheckbox"]').is(":checked")&&(E.releaseType==="Unstable"&&(v.commit=t('select[name="commits"] option:selected').val()),t('input[name="customDefines"]').val().split(" ").map(w=>w.trim()).forEach(w=>{v.options.push(w)}))),console.info("Build request:",v),e.buildApi.requestBuild(v,w=>{if(console.info("Build response:",w),e.targetDetail.file=w.file,!E.cloudBuild){e.buildApi.loadTargetHex(w.url,Q=>b(Q,w.file),i);return}d("Pending",w.key,0,!1),e.cancelBuild=!1,e.buildApi.requestBuildStatus(w.key,Q=>{if(Q.status==="success"){_(w,Q,"Cached");return}e.enableCancelBuildButton(!0);const fe=5;let q=1,te=!1,he=120;const Oe=setInterval(()=>{e.buildApi.requestBuildStatus(w.key,X=>{X.timeOut!==void 0&&(te||(te=!0,q=1),he=X.timeOut);const se=he/fe;if(X.status!=="queued"||q>se||e.cancelBuild){if(e.enableCancelBuildButton(!1),clearInterval(Oe),X.status==="success"){_(w,X,"");return}let ae="";q>se&&(ae="TimeOut"),e.cancelBuild&&(ae="Cancel"),C(w.key,ae);return}te&&d("Processing",w.key,q*(100/se),!1),q++})},fe*1e3)})},()=>{d("FailRequest","",0,!1),i()})}e.targetDetail?(t("a.load_remote_file").text(l.getMessage("firmwareFlasherButtonDownloading")),e.enableLoadRemoteFileButton(!1),c(e.targetDetail),S(e.targetDetail)):(t("span.progressLabel").attr("i18n","firmwareFlasherFailedToLoadOnlineFirmware").removeClass("i18n-replaced"),l.localizePage())}),t("a.exit_dfu").on("click",function(){if(e.enableDfuExitButton(!1),!m.connect_lock){N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"ExitDfu",null);try{console.log("Closing DFU"),z.requestPermission().then(s=>{z.connect(s.path,e.parsed_hex,{exitDfu:!0})})}catch(s){console.log(`Exiting DFU failed: ${s.message}`)}}});const de=t("#targetSupportInfoUrl");de.on("click",function(){let s="https://betaflight.com/docs/wiki/boards/archive/Missing";const i=`https://betaflight.com/docs/wiki/boards/current/${e.selectedBoard}`;He(i)&&(s=i),de.attr("href",s)});const ee=t("a.detect-board");ee.on("click",()=>{ee.toggleClass("disabled",!0),m.connect_lock||nt.verifyBoard(V.portPicker.selectedPort),setTimeout(()=>ee.toggleClass("disabled",!1),2e3)}),t("a.flash_firmware").on("click",function(){e.isFlashing=!0,m.interval_pause("sponsor");const s=t("input.flash_on_connect").is(":checked");e.enableFlashButton(!1),e.enableDfuExitButton(!1),e.enableLoadRemoteFileButton(!1),e.enableLoadFileButton(!1);function i(){e.developmentFirmwareLoaded&&!s?Ie():J()}s||!(V.portAvailable||m.connect_lock)?i():m.showYesNoDialog({title:l.getMessage("firmwareFlasherRemindBackupTitle"),text:l.getMessage("firmwareFlasherRemindBackup"),buttonYesText:l.getMessage("firmwareFlasherBackup"),buttonNoText:l.getMessage("firmwareFlasherBackupIgnore"),buttonYesCallback:()=>{m.connect_lock=!0,ot.execute(()=>{m.connect_lock=!1,i()})},buttonNoCallback:i})});function Ie(){const i="lastDevelopmentWarningTimestamp";function d(){const _={};_[i]=Date.now(),ze(_)}k=Ve(i),!k[i]||Date.now()-k[i]>864e5?Pe(d):J()}function Pe(s){const i=t("#dialogUnstableFirmwareAcknowledgement")[0],d=t("#dialogUnstableFirmwareAcknowledgement-flashbtn"),_=t('input[name="dialogUnstableFirmwareAcknowledgement-acknowledge"]');_.change(function(){t(this).is(":checked")?d.removeClass("disabled"):d.addClass("disabled")}),d.click(function(){i.close(),_.is(":checked")&&(s&&s(),J())}),t("#dialogUnstableFirmwareAcknowledgement-cancelbtn").click(function(){i.close()}),i.addEventListener("close",function(){_.prop("checked",!1).change()}),i.showModal()}function J(){if(!m.connect_lock)if(e.parsed_hex){try{e.config&&!e.parsed_hex.configInserted&&(new je().insertConfig(e.parsed_hex,e.config)?e.parsed_hex.configInserted=!0:(console.log("Firmware does not support custom defaults."),u())),Be(e.parsed_hex)}catch(s){console.log(`Flashing failed: ${s.message}`)}t("input.flash_on_connect").prop("checked",!1).change()}else t("span.progressLabel").attr("i18n","firmwareFlasherFirmwareNotLoaded").removeClass("i18n-replaced"),l.localizePage()}t("span.progressLabel").on("click","a.save_firmware",function(){K.pickSaveFile(e.targetDetail.file,l.getMessage("fileSystemPickerFiles",{typeof:"HEX"}),".hex").then(s=>{console.log("Saving firmware to:",s.name),K.writeFile(s,e.intel_hex),N.sendEvent(N.EVENT_CATEGORIES.FLASHING,"SaveFirmware")}).catch(s=>{console.error("Error saving file:",s)})}),e.flashingMessage(l.getMessage("firmwareFlasherLoadFirmwareFile"),e.FLASH_MESSAGE_TYPES.NEUTRAL),V.dfuAvailable&&t("a.exit_dfu").removeClass("disabled"),m.content_ready(r)}e.buildApi.loadTargets(()=>{console.log("Targets loaded"),t("#content").load("./tabs/firmware_flasher.html",a)})};M.validateBuildKey=function(){var r;return((r=this.cloudBuildKey)==null?void 0:r.length)===32&&ne()};M.cleanup=function(r){t(document).unbind("keypress"),t(document).off("click","span.progressLabel a"),r&&r()};M.enableCancelBuildButton=function(r){t("a.cloud_build_cancel").toggleClass("disabled",!r),self.cancelBuild=!1};M.enableFlashButton=function(r){t("a.flash_firmware").toggleClass("disabled",!r)};M.enableLoadRemoteFileButton=function(r){t("a.load_remote_file").toggleClass("disabled",!r)};M.enableLoadFileButton=function(r){t("a.load_file").toggleClass("disabled",!r)};M.enableDfuExitButton=function(r){t("a.exit_dfu").toggleClass("disabled",!r)};M.refresh=function(r){const e=this;m.tab_switch_cleanup(function(){e.initialize(),r&&r()})};M.showDialogVerifyBoard=function(r,e,a,o){const n=t("#dialog-verify-board")[0];t("#dialog-verify-board-content").html(l.getMessage("firmwareFlasherVerifyBoard",{selected_board:r,verified_board:e})),n.hasAttribute("open")||(n.showModal(),t("#dialog-verify-board-continue-confirmbtn").on("click",function(){n.close(),a()}),t("#dialog-verify-board-abort-confirmbtn").on("click",function(){n.close(),o()}))};M.FLASH_MESSAGE_TYPES={NEUTRAL:"NEUTRAL",VALID:"VALID",INVALID:"INVALID",ACTION:"ACTION"};M.flashingMessage=function(r,e){let a=this,o=t("span.progressLabel");switch(e){case a.FLASH_MESSAGE_TYPES.VALID:o.removeClass("invalid actionRequired").addClass("valid");break;case a.FLASH_MESSAGE_TYPES.INVALID:o.removeClass("valid actionRequired").addClass("invalid");break;case a.FLASH_MESSAGE_TYPES.ACTION:o.removeClass("valid invalid").addClass("actionRequired");break;case a.FLASH_MESSAGE_TYPES.NEUTRAL:default:o.removeClass("valid invalid actionRequired");break}return r!==null&&o.html(r),a};M.flashProgress=function(r){return t(".progress").val(r),this};M.injectTargetInfo=function(r,e,a,o){const n=/^# config: manufacturer_id: .*, board_name: .*, version: .*$, date: .*\n/gm,c=r.replace(n,""),u=`# config: manufacturer_id: ${a}, board_name: ${e}, version: ${o.commitHash}, date: ${o.date}`,p=c.split(`
`);return p.splice(1,0,u),p.join(`
`)};f.firmware_flasher=M;export{M as firmware_flasher};
